<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Grace</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:Grace.Data.IExtraDataContainer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="T:Grace.Data.NotifyObject">
            <summary>
            A base object that implements INotifyPropertyChanged and offers logging
            </summary>
        </member>
        <member name="M:Grace.Data.NotifyObject.SetProperty``1(``0@,``0,System.String)">
            <summary>
            Sets a value to a particular property while calling PropertyChanged
            Note: Default implementation from VS temlate
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="storage">backing field for the property</param>
            <param name="value">new value to set</param>
            <param name="propertyName">property name (usually left blank if calling from property)</param>
            <returns>true if the value was set (false if its the same value)</returns>
        </member>
        <member name="M:Grace.Data.NotifyObject.OnPropertyChanged(System.String)">
            <summary>
            Default implementation of Propertychanged event invoker
            </summary>
            <param name="propertyName">property that changed</param>
        </member>
        <member name="P:Grace.Data.NotifyObject.Log">
            <summary>
            ILog instance for this class
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ActivationCompleteAttribute">
            <summary>
            Methods that are attributed with this class will be called at the end of activation
            Note: the signature must be Action() or Action(IInjectionContext)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IActivationCompleteAttribute">
            <summary>
            Attibutes that implement this interface will be discovered during scanning
            It is to be used on methods that are to be called during activation
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportAttribute">
            <summary>
            This attribute is used to mark a type for export. 
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute">
            <summary>
            Attributes that implement this interface will be included while scanning for exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provide a list of export names that the type should be exported as
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>list of export names</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor">
            <summary>
            Default constructor. Export as the class name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor(System.String,System.String[])">
            <summary>
            exports using the provided export name
            </summary>
            <param name="exportName"></param>
            <param name="extraNames"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor(System.Type,System.Type[])">
            <summary>
            Export by type rather than by name
            </summary>
            <param name="exportType"></param>
            <param name="extraTypes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provide a list of export names that the type should be exported as
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>list of export names</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ExportAttribute.ExportNames">
            <summary>
            The list of export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ExportAttribute.ExportTypes">
            <summary>
            List of export types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute">
            <summary>
            Classes that have this attribute will be exported by the interfaces it implements
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provides a list of export name
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provides a list of export types (i.e. implemented interfaces)
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute">
            <summary>
            Attributes that implement this interface will be called during discover to provide a priority
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute.ProvidePriority(System.Type)">
            <summary>
            Provide the priority for an attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute">
            <summary>
            Limits an export to only be used when the class it's being injected into has the specified attribute
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute">
            <summary>
            Attributes that implement this interface can provide a condition for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default constructor that takes an attribute type to filter on
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide a condition for the type provided
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute">
            <summary>
            Attributes that implement this interface will be included while discovering attributes for importing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.ImportName">
            <summary>
            Import name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.Required">
            <summary>
            Is this import required. True by default
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ICustomInitializationAttribute">
            <summary>
            Attributes that implement this inteface will be used during discovery
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IEnrichWithAttribute">
            <summary>
            Attributes that implement will be called at discovery time to provide an EnrichWithDelegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IEnrichWithAttribute.ProvideDelegate(System.Type)">
            <summary>
            Provides an EnrichWithDelegate for an attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportEnvironmentAttribute">
            <summary>
            Attributes that implement this interface will be called during discovery time
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportEnvironmentAttribute.ProvideEnvironment(System.Type)">
            <summary>
            Provide the environment for the specified type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>export environment</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute">
            <summary>
            Attributes that implement this interface will be called during discovery to provide metadata for an attributed type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute.ProvideMetadata(System.Type)">
            <summary>
            Provide the metadata for an attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>a named piece of metadata</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute">
            <summary>
            Attributes that implement this interface will be called at discovery time to provide an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute.ProvideStrategy(System.Type)">
            <summary>
            Provide an export strategy for the attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo">
            <summary>
            Information about how the import should be performed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ImportName">
            <summary>
            The name of the import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ImportKey">
            <summary>
            The key that should be used when importing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ValueProvider">
            <summary>
            Value provider to use instead of looking up value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ExportStrategyFilter">
            <summary>
            Import Filter 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.Comparer">
            <summary>
            Comparer object for import
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportSortCollectionAttribute">
            <summary>
            This interface allows the developer to create a custom attribute that provides an IComparer(T) object to be used to sor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportSortCollectionAttribute.ProvideComparer(System.Type,System.String)">
            <summary>
            Provides an IComparer(T) 
            </summary>
            <param name="attributedType"></param>
            <param name="attributedName"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportValueProviderAttribute">
            <summary>
            Import attributes that implement this attribute can be used to import a particular value provider into 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportValueProviderAttribute.ProvideProvider(System.Type)">
            <summary>
            Provide an IExportValueProvider to be used on import
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ILifestyleProviderAttribute">
            <summary>
            Attributes that implement this interface will be queried during discovery to provide a life cycle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.ILifestyleProviderAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ImportAttribute">
            <summary>
            This attribute can be used to attribute properties, methods, constructors or parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Name">
            <summary>
            Name to use when importing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Key">
            <summary>
            Key to use when importing 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Required">
            <summary>
            Is this import required. True by default
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonAttribute">
            <summary>
            Exports attribute with this attribute will be shared as a single instance for all scopes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerInjectionContextAttribute">
            <summary>
            Exports marked with this attribute will be shared per injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerInjectionContextAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute">
            <summary>
            Exports that are marked with this attribute will be shared per request.
            Note: request has different meanings in different contexts.
            WCF - limited to per WCF operation
            MVC - Per HTTP Request
            Other - without a context the export will be shared for the injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute">
            <summary>
            Exports marked with this attribute will be shared per scope.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WeakSingletonAttribute">
            <summary>
            Exports attributed with this will be shared, the instance will be held with a weak reference so it will be GC'd when done
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WeakSingletonAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenClassHasAttribute">
            <summary>
            Export condition that limits the export to only be used in classes that have a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provides a new WhenClassHas condition
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute">
            <summary>
            Limits an export to only be used when being injected into one of the types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute">
            <summary>
            Limits an export to only be used when the importing member has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute">
            <summary>
            Limits an export to only be used when the target has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.IExportCondition">
            <summary>
            any class that implements this interface can be used as a condition on an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.IExportCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.MultipleConditions">
            <summary>
            Combines multiple conditions into one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.MultipleConditions.#ctor(Grace.DependencyInjection.Conditions.IExportCondition[])">
            <summary>
            Default Constructor
            </summary>
            <param name="exportConditions"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.MultipleConditions.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.UnlessCondition">
            <summary>
            Simple condition that exports unless the condition is meet
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.UnlessCondition.#ctor(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.UnlessCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenCondition">
            <summary>
            Simple condition true when delegate returns true
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenCondition.#ctor(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenDebuggerIsAttached">
            <summary>
            Export condition that limits the export to only be used when the debugger is attached
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenDebuggerIsAttached.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Returns true when the debugger is attached
            </summary>
            <param name="scope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenDebuggerIsNotAttached">
            <summary>
            Export condition that limits the export to only be used when there is no debugger
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenDebuggerIsNotAttached.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Returns true only when there is no debugger attached
            </summary>
            <param name="scope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenInjectedInto">
            <summary>
            Export condition that is true when being injected into
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="injectedType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenClassHas">
            <summary>
            Export condition that is true when class has a particular attribute on it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenMemberHas">
            <summary>
            Export condition that is true when the member (Constructor,Method or Property) has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenTargetHas">
            <summary>
            Export condition that is true when target has a particular attribute on it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportActivationDelegate">
            <summary>
            Delegate representing scope in wich this export is being activated
            </summary>
            <param name="injectionScope">scope that the export startegy is attached to, this can be different than it's owning scope</param>
            <param name="context">context for the injection</param>
            <returns>new activated object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Used to filter out exports
            </summary>
            <param name="context">context to use during filtering</param>
            <param name="strategy">strategy to filter</param>
            <returns>return true if the strategy should be used</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyComparer">
            <summary>
            Used to compare two exports within a particular export environment
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="exportEnvironment">current environment</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportRegistrationDelegate">
            <summary>
            This delegate allows you to provide extra registration during scope creation
            </summary>
            <param name="registration">registration object</param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportFunction`1">
            <summary>
            This delegate can be used to provide an export
            </summary>
            <typeparam name="T">type being returned</typeparam>
            <param name="injectionScope">injection scope</param>
            <param name="injectionContext">injection context</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.EnrichWithDelegate">
            <summary>
            Using this delegate you can provide custom logic to the activation process overriding 
            </summary>
            <param name="scope">injection scope for this export</param>
            <param name="injectionContext">injection context for this call</param>
            <param name="injectedObject">injected object</param>
            <returns>return the initial object or return a wrapping object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.BeforeDisposalCleanupDelegate">
            <summary>
            This delegate allows the developer to perform some cleanup before Dispose is called
            </summary>
            <param name="objectBeingDisposed"></param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportConditionDelegate">
            <summary>
            Delegate is used to figure out if the export strategy meets the proper condition
            </summary>
            <param name="scope">scope the export is in</param>
            <param name="injectionContext">injection context for this call</param>
            <param name="exportStrategy">export strategy being considered</param>
            <returns>return true if the export is to be considered</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportEnvironment">
            <summary>
            Defined what environement the application is running in or compenent is Exported in
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.Any">
            <summary>
            Can be used in any environment
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.RunTime">
            <summary>
            Best used at runtime
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.RunTimeOnly">
            <summary>
            Can only be used at runtime
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.DesignTime">
            <summary>
            Best used at design time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.DesignTimeOnly">
            <summary>
            Only used at design time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.UnitTest">
            <summary>
            Best used at unit test time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.UnitTestOnly">
            <summary>
            Only used at unit test time
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.DependencyLoopException">
            <summary>
            This exception is thrown when a loop is detected trying to resolve an export.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.ImportTypeMismatchException">
            <summary>
            Exception is thrown when there is a mismatch type when importing
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportsThat">
            <summary>
            static class that provides ExportStrategyFilter methods to be used during export registration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType">attribute type</param>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute">attribute type</typeparam>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace">namespace the type should be in</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type">class to check for</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T">class to check for</typeparam>
            <param name="includeSubnamespaces">include sub namespace</param>
            <returns>export configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyDependencyType">
            <summary>
            Represents the type of dependency for the export
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportStrategyDependencyType.ConstructorParameter">
            <summary>
            A constructor parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportStrategyDependencyType.Property">
            <summary>
            A Property
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportStrategyDependencyType.MethodParameter">
            <summary>
            A method parameter
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyDependency">
            <summary>
            Export strategy dependency
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.DependencyType">
            <summary>
            Type of dependency
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.TargetName">
            <summary>
            Name of the target being injected (ParameterName or PropertyName)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.ImportType">
            <summary>
            Type being imported, can be null when locating by name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.ImportName">
            <summary>
            name of export, can be null when locating by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.HasValueProvider">
            <summary>
            Has Value Provider
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.HasFilter">
            <summary>
            Has a filter for it's dependency
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyFilterGroup">
            <summary>
            A collection of export filters that can convert to one ExportStrategyFilter
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.#ctor(Grace.DependencyInjection.ExportStrategyFilter[])">
            <summary>
            Default Constructor
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.op_Implicit(Grace.DependencyInjection.ExportStrategyFilterGroup)~Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Converts export filter group to export strategy filter
            </summary>
            <param name="exportStrategyGroup"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.InternalExportStrategyFilter(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Internal filter method that loops through the collection of filters
            </summary>
            <param name="context">injection context</param>
            <param name="strategy">export strategy</param>
            <returns>true if the strategy matches</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocator">
            <summary>
            This interface can be used to locate an export. It's used by IInjectionScope and IDependencyInjectionContainer
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the container.
            </summary>
            <param name="newLocator">new secondary locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddStrategyInspector(Grace.DependencyInjection.IStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="registrationDelegate">delegate used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope provider for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule">configuration module used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="registrationDelegate">registration delegate used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="configurationModule">configuration module used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context
            </summary>
            <returns>new injection context</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext">injection context for the locate</param>
            <param name="consider">filter to be used when locating</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>export T if found, other wise default(T)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType">type to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating export</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName">name of export to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="comparer">used for sorting the imports when returning the list</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>List of T, this will return an empty list if not exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name">export name to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="comparer"></param>
            <returns>List of objects, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <returns>list of object, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategyCollection(System.String)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportName"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocator.SecondaryExportLocators">
            <summary>
            List of Export Locators
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocator.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocatorExtensions">
            <summary>
            Extension methods for IExportLocator
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.WhatDoIHave(Grace.DependencyInjection.IExportLocator,System.Boolean)">
            <summary>
            This method returns a summary of the exports contained in an ExportLocator
            </summary>
            <param name="locator"></param>
            <param name="includeParent"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``2(Grace.DependencyInjection.IExportLocator,``1,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type with a key
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <typeparam name="TKey">type of key</typeparam>
            <param name="locator">locator to use</param>
            <param name="key">key to use while locating</param>
            <param name="injectionContext">injection context to use</param>
            <param name="consider">filter method to use</param>
            <returns>export T</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``1(Grace.DependencyInjection.IExportLocator,System.String,``0,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name and key
            </summary>
            <typeparam name="TKey">key type</typeparam>
            <param name="locator">locator to use</param>
            <param name="exportName">name of export to locate</param>
            <param name="key">key to use during location</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter method</param>
            <returns>export object, null if no object found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``1(Grace.DependencyInjection.IExportLocator,System.Type,``0,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type and key
            </summary>
            <typeparam name="TKey">key type to locate</typeparam>
            <param name="locator">locator to use</param>
            <param name="exportType">type to locate</param>
            <param name="key">key to use while locating</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <returns>export object, null if no export found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.CompareKeyFunction(System.Object,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Function to compare a key to an export strategy
            </summary>
            <param name="key"></param>
            <param name="context"></param>
            <param name="strategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportMetadata">
            <summary>
            
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportMetadata.Key">
            <summary>
            Key that the export was registered with
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration">
            <summary>
            This inteface allows you to configure an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportProperty(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportMethod(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="methodName">name of method to import</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExportProperty(System.String)">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName">name of property to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod">name of method to activate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="lifestyle">Lifestyle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            Note: Only public writeable properties will be imported
            </summary>
            <param name="required">are all the properties required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParamCollection``2">
            <summary>
            Adds a constructor param of type TParam to the constructor
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1">
            <summary>
            This interface allows you to configure an export strategy for type T
            </summary>
            <typeparam name="T">type to export</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ByInterfaces">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithKey(System.Object)">
            <summary>
            Attach a key to the export
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportCollectionProperty``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Import a property as a collection allowing for you to specify the sort order for the import
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a method to be called upon activation passing in an arguement that has be located using the IoC
            </summary>
            <param name="method">method to import</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Export a property to be imported by other exports
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.UsingLifestyleContainer(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorCollectionParam``2">
            <summary>
            Import a collection allowing you to specify a filter and a sort order
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration">
            <summary>
            Simple export strategy, used to export a type using only Constructor injection
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.As``1">
            <summary>
            Export as a particular type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="lifestyle">Lifestyle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1">
            <summary>
            Configuration object for an imoprt collection
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.SortByProperty(System.Func{`0,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.SortBy(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2">
            <summary>
            Configuration object for an imoprt collection
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.SortByProperty(System.Func{`1,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.SortBy(System.Collections.Generic.IComparer{`1})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy">
            <summary>
            Closed generic strategy is used to create closed strategies by the generic strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy">
            <summary>
            This class exports a type using linq expressions
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExportStrategy">
            <summary>
            Represents an export strategy that can be configured to build a CompiledExportDelegate
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ConfigurableExportStrategy">
            <summary>
            This is the base export class, it provides method to configure itself
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IConfigurableExportStrategy">
            <summary>
            This interface is implemented by classes that can be configured for exporting
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategy">
            <summary>
            Classes that implement this interface can be used to export a particular type
            Note: All implementations of ExportStrategy should be thread safe. 
            It is expected that N number callers can activate at the same time.
            It's also recommended that the strategy me as immutable as possible
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportValueProvider">
            <summary>
            Classes that implement this interface can be used to provide an import value during construction
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportValueProvider.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext">injection context</param>
            <returns>true if the export should be used</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns>a list of strategies this export exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate">delegate called during activation</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.Lock">
            <summary>
            Lock the export from changing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetKey(System.Object)">
            <summary>
            Set the key value for the strategy
            </summary>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddExportName(System.String)">
            <summary>
            Add an export name for strategy
            </summary>
            <param name="exportName">new export name</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType">new type to export</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Set the export environment for the strategy
            </summary>
            <param name="environment">environment this export should be exported in</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetPriority(System.Int32)">
            <summary>
            Set the priority for the strategy
            </summary>
            <param name="priority">priority for the export</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetExternallyOwned">
            <summary>
            Set the export to be externally owned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetLifestyleContainer(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set the life cycle container for the strategy
            </summary>
            <param name="container">new Lifestyle container for the export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Add a condition to the export
            </summary>
            <param name="exportCondition">export condition for strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddMetadata(System.String,System.Object)">
            <summary>
            Add metadata to export
            </summary>
            <param name="name">metadata name</param>
            <param name="value">metadata value</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Dispose">
            <summary>
            Dispose this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Lock">
            <summary>
            Locks the export for any more changes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetKey(System.Object)">
            <summary>
            Set the key value for the strategy
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddExportName(System.String)">
            <summary>
            Add an export name for strategy
            </summary>
            <param name="exportName"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Set the export environment for the strategy
            </summary>
            <param name="environment"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetPriority(System.Int32)">
            <summary>
            Set the priority for the strategy
            </summary>
            <param name="priority"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetLifestyleContainer(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set the life cycle container for the strategy
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Add a condition to the export
            </summary>
            <param name="exportCondition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddMetadata(System.String,System.Object)">
            <summary>
            Add metadata to the export
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Dispose(System.Boolean)">
            <summary>
            Dispose of this object
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ActivationType">
            <summary>
            Activation Type for this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Metadata">
            <summary>
            Metadata for export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ICompiledExportStrategy">
            <summary>
            This interface represents an export strategy that can be configured for importing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Configure the export to import a method
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Configure the export to import a property
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ExportProperty(Grace.DependencyInjection.Impl.ExportPropertyInfo)">
            <summary>
            mark a property for exporting
            </summary>
            <param name="exportProperty"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Configure a method for activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Specify a particular constructor
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.WithCtorParam(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="constructorParamInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds a cleanup delegate to export strategy
            </summary>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ICompiledExportStrategy.CreatingStrategy">
            <summary>
            When the strategy has been created by a generic strategy this will be set to the strategy that created it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Configure the export to import a method
            </summary>
            <param name="methodInfo"></param>
            <param name="importValues"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Configure the export to import a property
            </summary>
            <param name="propertyInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Configure a method for activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Specify a particular constructor
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.WithCtorParam(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="constructorParamInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds a cleanup delegate to export strategy
            </summary>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.GetCompiledInfo">
            <summary>
            Gets the CompiledExportDelegateInfo definition for this export
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExportStrategy.CreatingStrategy">
            <summary>
            When the strategy has been created by a generic strategy this will be set to the strategy that created it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.Equals(System.Object)">
            <summary>
            OVerride equals to compare if to closed generics are equal
            </summary>
            <param name="obj">object to compare</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.GetHashCode">
            <summary>
            Gets hashcode of activation name
            </summary>
            <returns>hash code value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate">
            <summary>
            THis class creates a compiled delegate that can be used for export
            It uses a function to create a new instance
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate">
            <summary>
            This class is used to create a delegate that creates an export and statisfies all it's imports
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.disposalExpressions">
            <summary>
            List of expressions for handling IDisposable
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.exportStrategyScopeParameter">
            <summary>
            The IInjectionScope parameter for the strategy
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.importInjectionContextExpressions">
            <summary>
            List of expressions that loacte the import from the injection context before resolving
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.injectionContextParameter">
            <summary>
            The IInjectionContext parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.instanceExpressions">
            <summary>
            List of expressions used to construct the instance
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.instanceVariable">
            <summary>
            Variable that represents the instance being constructed
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.isRequiredExpressions">
            <summary>
            List of expressions that test if an import is null
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CompileDelegate">
            <summary>
            Compiles the export delegate
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.GenerateDelegate">
            <summary>
            This method generates the compiled delegate
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.SetUpParameterExpressions">
            <summary>
            Sets up the parameters for the delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.SetUpInstanceVariableExpression">
            <summary>
            Sets up a local variable that hold the instance that will be injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateInstantiationExpression">
            <summary>
            This method creates the expression that calls the constructor or function to create a new isntance that will be returned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateCustomInitializeExpressions">
            <summary>
            This method creates expressions that call Initialization methods (i.e. methods that take IInjectionContext and are called after
            construction and before properties are injected)
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreatePropertyImportExpressions">
            <summary>
            Creates all the import expressions for properties that are being injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateMethodImportExpressions">
            <summary>
            Creates all method import expressions for the export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateActivationMethodExpressions">
            <summary>
            Create all the expressions for activatition methods
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateDisposableMethodExpression">
            <summary>
            Create expressions for disposable objects
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateEnrichmentExpression">
            <summary>
            
            </summary>
            <returns>true if there was an enrichment expression created</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.ExecuteEnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object)">
            <summary>
            This method is used to execute an EnrichWithDelegate
            </summary>
            <param name="enrichWithDelegate"></param>
            <param name="scope"></param>
            <param name="context"></param>
            <param name="injectObject"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateReturnExpression">
            <summary>
            Creates a return expression 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateImportExpression(System.Type,Grace.DependencyInjection.IInjectionTargetInfo,Grace.DependencyInjection.ExportStrategyDependencyType,System.String,System.String,System.Boolean,Grace.DependencyInjection.IExportValueProvider,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Creates a local variable an then tries to import the value
            </summary>
            <param name="importType"></param>
            <param name="targetInfo"></param>
            <param name="dependencyType"></param>
            <param name="exportName"></param>
            <param name="variableName"></param>
            <param name="isRequired"></param>
            <param name="valueProvider"></param>
            <param name="exportStrategyFilter"></param>
            <param name="comparerObject"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFunc``1(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new Func(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionScope"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFuncWithContext``1(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new Func(IInjectionContext,T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionScope"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFuncType(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new Func(Type,object) for resolving type without having to access container
            </summary>
            <param name="injectionScope">injection scope to use</param>
            <param name="exportStrategyFilter">export filter to use when locating</param>
            <returns>new Func(Type,object)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFuncTypeWithContext(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Create a new Func(Type, IInjectionContext, object) for resolving type without having to access container
            </summary>
            <param name="injectionScope"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateOwned``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new Owned(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateLazy``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Create a new Lazy(T) 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.Dependencies">
            <summary>
            Dependencies for this compiled delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="activationDelegate"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.CreateInstantiationExpression">
            <summary>
            This method creates the expression that calls the constructor or function to create a new isntance that will be returned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.InvokeActivationDelegate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method used to invoke an activation delegate
            </summary>
            <param name="exportStrategyScope"></param>
            <param name="activationDelegate"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.InjectionTargetExtraDataKey">
            <summary>
            Extra Data Key for Injection Target
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.LocateInjectionObject(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Returns the injection target
            </summary>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate">
            <summary>
            This class compiles a delegate to be used for exporting. 
            It creates a new instance using the types constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate.PickConstructor(System.Type)">
            <summary>
            Picks the specific constructor to use for exporting
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.SimpleCompiledExportDelegate.GenerateDelegate">
            <summary>
            This method generates the compiled delegate
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.AttributeExportStrategy">
            <summary>
            Exports a type using attributes to define how it should be exported
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributeExportStrategy.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            DEfault constructor
            </summary>
            <param name="exportType"></param>
            <param name="attributes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributeExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportMetadata">
            <summary>
            Export metadata 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.#ctor(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Default Constructor
            </summary>
            <param name="key"></param>
            <param name="dictionary"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration">
            <summary>
            Base export strategy configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            default constructor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ImportProperty(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ImportMethod(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="methodName">name of method to import</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ExportProperty(System.String)">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName">name of property to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod">name of method to activate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="container">Lifestyle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            Note: Only public writeable properties will be imported
            </summary>
            <param name="required">are all the properties required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithCtorParamCollection``2">
            <summary>
            Adds a constructor param of type TParam to the constructor
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1">
            <summary>
            Base export strategy configuration
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ByInterfaces">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithKey(System.Object)">
            <summary>
            Attach a key to the export
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportCollectionProperty``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Import a property as a collection allowing for you to specify the sort order for the import
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a method to be called upon activation passing in an arguement that has be located using the IoC
            </summary>
            <param name="method">method to import</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Export a property to be imported by other exports
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.UsingLifestyleContainer(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithCtorCollectionParam``2">
            <summary>
            Import a collection allowing you to specify a filter and a sort order
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration">
            <summary>
            This class allows you to configure a type for exporting using fluent syntax
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IExportStrategyProvider">
            <summary>
            Used by classes that provide strategies to the registration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportStrategyProvider.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ProcessCurrentConstructorParamInfo">
            <summary>
            Processes the current constructor parameter that was being configured
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.#ctor(System.Type,Grace.DependencyInjection.Impl.ICompiledExportStrategy)">
            <summary>
            
            </summary>
            <param name="exportType"></param>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of calling Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            </summary>
            <param name="required"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1">
            <summary>
            This class configures a particular type for export using fluent syntax
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.#ctor(Grace.DependencyInjection.Impl.ICompiledExportStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ByInterfaces">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithKey(System.Object)">
            <summary>
            Export under a specific key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( x => new MyTypeName("Specific","Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( x => new MyTypeName("Specific","Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.UsingLifestyleContainer(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2">
            <summary>
            Creates a new instance of any class that implements ICollection(TItem)
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Equals(System.Object)">
            <summary>
            Override to compare 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.GetHashCode">
            <summary>
            Overriding because I'm overriding equals
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.ExportNames">
            <summary>
            Export names for this collection
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1">
            <summary>
            This strategy takes a func and calls it when ever
            </summary>
            <typeparam name="T">type of instance that will be exported</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.#ctor(Grace.DependencyInjection.ExportFunction{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="instanceFunc">export func</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope">export injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">export strategy filter</param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.InternalActivate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            internal activate method
            </summary>
            <param name="injectionscope">injection scope</param>
            <param name="context">injection context</param>
            <returns>export instance</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PropertyExportStrategy">
            <summary>
            Property Export exports a property from another IExportStrategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.#ctor(System.Reflection.PropertyInfo,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Default constructor
            </summary>
            <param name="property"></param>
            <param name="targetStrategy"></param>
            <param name="exportCondition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            If this strategy meets condition and the target target strategy meets condition
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.BuildAccessor">
            <summary>
            Builds an accessor method 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategy.WithCtorParam(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="constructorParamInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategy.GetCompiledInfo">
            <summary>
            Gets the CompiledExportDelegateInfo definition for this export
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy.CheckGenericConstrataints(System.Type[])">
            <summary>
            Checks to make sure the closing types meet generic constraints
            </summary>
            <param name="closingTypes"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy.CreateClosedStrategy(System.Type[])">
            <summary>
            Creates a new closed export strategy that can be activated
            </summary>
            <param name="closingTypes"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IStrategyInspector">
            <summary>
            Classes that implement this interface can be used to inspect strategies as they are being added to the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IStrategyInspector.StrategyInitializing(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called everytime a strategy about to be added to the the IInjectionScope
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportsThatConfiguration">
            <summary>
            Configuration for ExportsThat, build a 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType">attribute type</param>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute">attribute type</typeparam>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace">namespace the type should be in</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type">class to check for</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T">class to check for</typeparam>
            <param name="includeSubnamespaces">include sub namespace</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.op_Implicit(Grace.DependencyInjection.Impl.ExportsThatConfiguration)~Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Converts the configuration to a filter automatically
            </summary>
            <param name="configuration">configuration object</param>
            <returns>new filter method</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IMissingExportHandler">
            <summary>
            This interface is an internal interface that is used to tell the scope that there is a missing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IMissingExportHandler.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate missing exports
            </summary>
            <param name="context">injection context</param>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="consider">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator">
            <summary>
            This class is a simple secondary resolver implementation
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ISecondaryExportLocator">
            <summary>
            Classes that wish to participate in resolving unknown exports can implement this interface.
            If an export can't be located in a scope a secondary dependency resolvers will be called
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.CanLocate(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Can locate a type
            </summary>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate will be called when the injection scope can't locate a particular resource
            </summary>
            <param name="owningScope">the scope that the locate came through</param>
            <param name="context">injection context for the locate</param>
            <param name="resolveName">name being resolved</param>
            <param name="resolveType">type being resolved</param>
            <param name="consider">filter to use while resolving</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.LocateAll(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            LocateAll will be called every time a collection is resolved
            </summary>
            <param name="owningScope">the scope that the locate came through</param>
            <param name="context">injection context for the locate</param>
            <param name="resolveName">name of the export being resolved</param>
            <param name="resolveType">type that is being resolved</param>
            <param name="collectionEmpty">value saying if there are already values in the collection</param>
            <param name="consider">filter to use while locating</param>
            <returns>list of exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Default constructor
            </summary>
            <param name="initValues"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.CanLocate(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Can locate a type
            </summary>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Resolve will be called when the injection scope can't locate a particular resource
            </summary>
            <param name="owningScope"></param>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.LocateAll(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            ResolveAll will be called every time a collection is resolved
            </summary>
            <param name="owningScope"></param>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="collectionEmpty"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(System.Func{``0})">
            <summary>
            Adds a value to the resolver
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue(System.String,System.Object)">
            <summary>
            Adds a resolve value but name
            </summary>
            <param name="resolveName"></param>
            <param name="resolveValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(System.String,System.Func{``0})">
            <summary>
            Adds a value to the resolver
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveName"></param>
            <param name="resolveFunc"></param>
        </member>
        <member name="T:Grace.DependencyInjection.IConfigurationModule">
            <summary>
            Classes that implement this method can be used to configure a registration scope or container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurationModule.Configure(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Called by the injection scope to add exports to the scope
            </summary>
            <param name="registrationBlock"></param>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScopeProvider">
            <summary>
            Provides disposal scopes for an IInjectionScope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScopeProvider.ProvideDisposalScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Provides a default disposal scope, otherwise the current IInjectionScope will be used
            </summary>
            <param name="injectionScope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1">
            <summary>
            This interface allows you to configure an instance for export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as a particular interface
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if the Property or method or constructor is attribute with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a lifestyle to use with the export
            </summary>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportRegistrationBlock">
            <summary>
            This interface allows you to register exports.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Type)">
            <summary>
            Register an export by it's type. This is required when dealing with open generics
            </summary>
            <param name="type">type to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export``1">
            <summary>
            Export a class by it's type. This method allows you to specify things using linq expressions
            </summary>
            <typeparam name="T">type to export</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Export a collection of types all at one time
            </summary>
            <param name="types">collection of types to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly for exports.
            </summary>
            <param name="assembly">assembly to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Register a set of assemblies.
            </summary>
            <param name="assemblies">list of assemblies to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T">instance type</typeparam>
            <param name="instance">instance to export</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunction">Func that creates instance</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFunc``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export function, it allows you to import properties, import method and activate methods
            of the T returned by the Func, if you don't need this functionality I recommend using ExportInstance
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="exportFunction">Function to create instance of T</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.SimpleExport``1">
            <summary>
            Simple export allows you to export a type with a smaller set of options.
            This method should be used to register types in child containers because the registration process is
            much faster than Export and ExportFunc (though the fastest registeration option is still ExportInstance)
            </summary>
            <typeparam name="T">type to export</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.SimpleExport(System.Type)">
            <summary>
            Simple export allows you to export a type with a smaller set of options.
            This method should be used to register types in child containers because the registration process is
            much faster than Export and ExportFunc (though the fastest registeration option is still ExportInstance)
            </summary>
            <param name="type">export type</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddExportStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy directly to a scope
            </summary>
            <param name="strategy">new startegy</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IDependencyInjectionContainer">
            <summary>
            This interface defines the base functionality for the container
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScope">
            <summary>
            Defines a scope for injection that will dispose any objects added to it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add an object for disposal 
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove an object from the disposal scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.BlackListExport(System.String)">
            <summary>
            Black lists a particular export (Fullname)
            </summary>
            <param name="exportType">full name of type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.BlackListExportType(System.Type)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType">type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="registrationDelegate">delegate to be used to configure the scope</param>
            <param name="scopeName">scope name to configure</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="configurationModule">configuration module object to be used configure the scope</param>
            <param name="scopeName">name of scope to configure</param>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.AutoRegisterUnknown">
            <summary>
            If a concrete type is requested and it is not registered an export strategy will be created.
            Note: It will be scanned for attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.ThrowExceptions">
            <summary>
            If true exception will be thrown if a type can't be located, otherwise it will be caught and errors logged
            False by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.RootScope">
            <summary>
            The root scope for the container
            </summary>
        </member>
        <member name="E:Grace.DependencyInjection.IDependencyInjectionContainer.ResolveUnknownExports">
            <summary>
            Handling this event allows you to add exports to the container when an export can't be located.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetConfiguration">
            <summary>
            Allows you to configure an assembly for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>returns self</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.BasedOn(System.Type)">
            <summary>
            Export all types based on speficied type
            </summary>
            <param name="baseType">base type to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithPriority(System.Int32)">
            <summary>
            Export with the spcified priority
            </summary>
            <param name="priority">priority to export at</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export in the specified Environment
            </summary>
            <param name="environment">environment to export in</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExternallyOwned">
            <summary>
            Mark the exports to be externally owned, stopping the container from calling the Dispose
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndWeakSingleton">
            <summary>
            Exports are to be marked as shared, similar to a singleton only using a weak reference.
            It can not be of type IDisposable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndSingleton">
            <summary>
            Export services as Singletons
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set a particular life style 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export all attributed types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Select(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to filter out types based on the provided where clause
            </summary>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategyCollection">
            <summary>
            Represents a collection of export strategies for a particular export name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.ActivateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate all instances of a type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="injectionContext">injection context</param>
            <param name="filter">export filter</param>
            <returns>list of exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.Activate(System.String,System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the first export strategy that meets conditions
            </summary>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="injectionContext">injection context</param>
            <param name="filter">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.AddExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy to the collection
            </summary>
            <param name="exportStrategy">new export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.RemoveExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Remove an export strategy from the collection
            </summary>
            <param name="exportStrategy">old export strategy</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategyCollection.ExportStrategies">
            <summary>
            A enumerable of export strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionContext">
            <summary>
            There is one new Injection context object created for each injection request.
            It holds information pertinent to this injection
            Note: The implementation for IInjectionContext is not thread safe
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Locate``1">
            <summary>
            Locate an export by type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Locate(System.String)">
            <summary>
            Locate an export by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Export``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export by type for this injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Export(System.Type,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Export a type with an activation delegate
            </summary>
            <param name="exportType"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Export(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Register an export by name for this injection context
            </summary>
            <param name="name"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.IncrementResolveDepth">
            <summary>
            Increment the resolve depth by one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.DecrementResolveDepth">
            <summary>
            Decrement the resolve depth by one
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.DisposalScope">
            <summary>
            The disposal scope associated with this injection request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.RequestingScope">
            <summary>
            The scope that the request originated in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.TargetInfo">
            <summary>
            The target information for the current injection, 
            specifically what is the type you are being injected into and what is the PropertyInfo or ParameterInfo being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.MaxResolveDepth">
            <summary>
            Max resolve depth allowed
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionScope">
            <summary>
            IInjectionScope represents a scope for injection that can be created and inherited from at any time
            Note: The implementation for IInjectionScope is thread safe. 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.Container">
            <summary>
            The container this scope was created in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ScopeId">
            <summary>
            Unique identifier for the instance of the injection scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ScopeName">
            <summary>
            The scopes name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ParentScope">
            <summary>
            Parent scope, can be null if it's the root scope
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionTargetInfo">
            <summary>
            Defines properties that are specific to the property that is being imported
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTypeAttributes">
            <summary>
            These are the attributes for the class that it's being injected into
            Null if it's the root object in the dependency graph
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetName">
            <summary>
            This is the property or parameter name being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetType">
            <summary>
            This the type for the Property or Parameter being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionMemberAttributes">
            <summary>
            Attributes on the Constructor, Method, or Property being injected
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ArrayExportStrategy`1">
            <summary>
            Creates a new array export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the array
            </summary>
            <param name="exportInjectionScope">injection scope that this activation is associated with</param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Equals(System.Object)">
            <summary>
            Overriding equals so multiple instances of Array
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.GetHashCode">
            <summary>
            Gets the hashcode for the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo">
            <summary>
            Represents the information needed to build a compiled delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.AddConstructorParamInfo(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds a constructor parameter info
            </summary>
            <param name="paramInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Imports a property for the export
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Mark a method for importing 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Mark a method to be called during activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Add an enrich with delegate to the strategy
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.SetImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Sets the constructor info for the export
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds new cleanup delegate 
            </summary>
            <param name="newCleanupDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.Attributes">
            <summary>
            Attributes associated with the export type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.IsTransient">
            <summary>
            Is this export transient
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.TrackDisposable">
            <summary>
            Track the export if disposable
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivationType">
            <summary>
            This is the type that is being activated can be interface
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.CleanupDelegate">
            <summary>
            
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportProperties">
            <summary>
            List of properties to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportMethods">
            <summary>
            List of methods to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportConstructor">
            <summary>
            Constructor to use for importing, can be null
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ConstructorParams">
            <summary>
            List of constructor arguements
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivationMethodInfos">
            <summary>
            List of activation methods 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichmentDelegates">
            <summary>
            List of enrichment delegates to apply to the export
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo">
            <summary>
            Information on how to import a method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.AddMethodParamInfo(Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo)">
            <summary>
            Add a method parameter
            </summary>
            <param name="methodParamInfo"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.MethodToImport">
            <summary>
            Import the method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.MethodParamInfos">
            <summary>
            List of method params for the import
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo">
            <summary>
            Information on how to import method parameter
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo">
            <summary>
            Information on how to import a property
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ImportName">
            <summary>
            Import name to use if not importing by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.Property">
            <summary>
            Property to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ValueProvider">
            <summary>
            Value provider for the import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ExportStrategyFilter">
            <summary>
            Export filter associated with this import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ComparerObject">
            <summary>
            IComparer(T) to be used to sort collections
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo">
            <summary>
            Information about a constructor arguement
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ParameterName">
            <summary>
            Name of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ParameterType">
            <summary>
            Type of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ImportName">
            <summary>
            Import name to use if not importing by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ValueProvider">
            <summary>
            The value provider
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ExportStrategyFilter">
            <summary>
            Export filter associated with this import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ComparerObject">
            <summary>
            IComparer(T) to use to compare export values
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.BlackList">
            <summary>
            Represents a list of exports that should be black listed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.GetEnumerator">
            <summary>
            returns a list of class names that are black listed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.Add(System.String)">
            <summary>
            adds a new name to the black list
            </summary>
            <param name="blackedOut"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.Add(System.Type)">
            <summary>
            Add a new type to black list
            </summary>
            <param name="blackOutType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.IsExportStrategyBlackedOut(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Checks to see if an export strategy is on the black list.
            </summary>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1">
            <summary>
            This export takes an activation delegate and creates a linq compiled expression
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.#ctor(Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="exportActivationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DisposalScope">
            <summary>
            Represents a disposal scope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope.disposed">
            <summary>
            true if the object has already been disposed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.Dispose">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add and object to the scope for disposal
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove the object from the scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.Dispose(System.Boolean)">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.TrackedDisposables">
            <summary>
            Returns a list of all objects being tracked
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException">
            <summary>
            This exception is thrown when an IDisposable object is requested and no disposal scope is present.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="activationType"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration">
            <summary>
            Exports a set of types based on a provided configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.#ctor(Grace.DependencyInjection.IInjectionScope,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionScope"></param>
            <param name="scanTypes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>returns self</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="filterMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.BasedOn(System.Type)">
            <summary>
            Export all types based on speficied type
            </summary>
            <param name="baseType">base type to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithPriority(System.Int32)">
            <summary>
            Export with the spcified priority
            </summary>
            <param name="priority">priority to export at</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export in the specified Environment
            </summary>
            <param name="environment">environment to export in</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndWeakSingleton">
            <summary>
            Exports are to be marked as shared, similar to a singleton only using a weak reference.
            It can not be of type IDisposable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndSingleton">
            <summary>
            Export services as Singletons
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set a particular life cycle 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export all attributed types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Select(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to filter out types based on the provided where clause
            </summary>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1">
            <summary>
            Configures an instance for export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.#ctor(System.Type,Grace.DependencyInjection.Impl.IConfigurableExportStrategy)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportType"></param>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as a particular interface
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if the Property or method or constructor is attribute with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportRegistrationBlock">
            <summary>
            This class implements the IExportRegistrationBlock interface and provides exports for IInjectionScope
            Note: this class is not thread safe. You can call configure from multiple threads on the same scope
            but you can not call from multiple threads to the same instance of a registration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Type)">
            <summary>
            Register an export by it's type. This is required when dealing with open generics
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export``1">
            <summary>
            Register an export by it's type. This method allows you to specify things using linq expressions
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Register a collection of types all at one time
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly for exports. You can perform any of these
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Register a set of assemblies.
            </summary>
            <param name="assemblies"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFunc``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export function
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddExportStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy directly to a scope
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetExportStrategies">
            <summary>
            Get all exports for the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.FilterOutBasedOnEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Filter out strategies that are exported for particular environments
            </summary>
            <param name="strategyEnvironment"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportStrategyListProvider">
            <summary>
            List of export strategies that can act as a IExportStrategyProvider
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyListProvider.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncExportStrategy`1">
            <summary>
            This export strategy creates a new Func(T) that calls the current scope 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Dispose">
            <summary>
            Dispose the func export, nothing to do
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncValueProvider`1">
            <summary>
            A value provider that calls a func to generate it's export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncValueProvider`1.#ctor(System.Func{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncValueProvider`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1">
            <summary>
            A value provider that calls a func to generate it's export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1.#ctor(System.Func{Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.DependsOn">
            <summary>
            
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseGenericFuncExportStrategy.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2">
            <summary>
            Export strategy that creates a Func(TIn, TOut)
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3">
            <summary>
            Export strategy that creates Func(TIn1, TIn2, Tout)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4">
            <summary>
            Export strategy that creates a Func(TIn1, Tin2, TIn3, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5">
            <summary>
            Creates a new Func(TIn1, TIn2, TIn3, TIn4, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TIn4"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6">
            <summary>
            Creates a new Func(TIn1, TIn2, TIn3, TIn4, TIn5, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TIn4"></typeparam>
            <typeparam name="TIn5"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericExportStrategy">
            <summary>
            Represents a generic export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.CheckGenericConstrataints(System.Type[])">
            <summary>
            Checks to make sure the closing types meet generic constraints
            </summary>
            <param name="closingTypes"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.CreateClosedStrategy(System.Type[])">
            <summary>
            Creates a new closed export strategy that can be activated
            </summary>
            <param name="closingTypes"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportPropertyInfo">
            <summary>
            Information to export a property on an object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportPropertyInfo.AddExportType(System.Type)">
            <summary>
            Add a type to the export info
            </summary>
            <param name="exporType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportPropertyInfo.AddExportName(System.String)">
            <summary>
            Add an export name to export property
            </summary>
            <param name="exportName"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.PropertyInfo">
            <summary>
            Property to export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.ExportTypes">
            <summary>
            Export Type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.ExportNames">
            <summary>
            Export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.ExportCondition">
            <summary>
            Export Condition
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionTargetInfo">
            <summary>
            Represents the information about injecting a particular object into another
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionTargetInfo.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Attribute},System.Object,System.Collections.Generic.IEnumerable{System.Attribute},System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType">the type that is being injected into</param>
            <param name="injectionTypeAttributes">attributes on the type being injected</param>
            <param name="injectionTarget">the ParameterInfo or PropertyInfo being injected into</param>
            <param name="injectionTargetAttributes">attributes on the ParameterInfo or PropertyInfo</param>
            <param name="injectionMemberAttributes">attribute on the Method,Constructor, or Property</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTypeAttributes">
            <summary>
            These are the attributes for the class that it's being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetName">
            <summary>
            This is the property or parameter name being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetType">
            <summary>
            This the type for the Property or Parameter being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionMemberAttributes">
            <summary>
            Attributes associated with Constructor, Property or Method that is being injected
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategy`1">
            <summary>
            Instance strategy represents the export strategy for a particular export instance
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategy`1.#ctor(`0)">
            <summary>
            Default Constructor
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Return the instance
            </summary>
            <param name="exportInjectionScope">injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.RootScopeCloneException">
            <summary>
            This exception is thrown when you attempt to clone an InjectionKernel that doesn't have a parent
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.RootScopeCloneException.#ctor(System.String,System.Guid)">
            <summary>
            Default Constructor
            </summary>
            <param name="scopeName"></param>
            <param name="scopeId"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.LazyExportStrategy`1">
            <summary>
            Export strategy creates a new Lazy(T)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Dispose">
            <summary>
            Dipose the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Equals(System.Object)">
            <summary>
            Override equals 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.GetHashCode">
            <summary>
            Override because of equals override
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ListExportStrategy`1">
            <summary>
            Export Strategy for creating List(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Dispose">
            <summary>
            Dispose the Export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.OwnedStrategy`1">
            <summary>
            An export strategy for creating Owned(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1">
            <summary>
            Export strategy to create ReadOnlyCollection(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Dispose">
            <summary>
            Dispose strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.SecondaryStrategies">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Equals(System.Object)">
            <summary>
            Override equals to check if the export strategy is the same
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.GetHashCode">
            <summary>
            Override because of equals override
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.ILifestyle">
            <summary>
            ILifestyle objects are used to manage the Lifestyle of a particular export
            Singleton, Shared, Cached, and PerRequest are examples of Lifestyle containers
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.ILifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.DependencyInjectionContainer">
            <summary>
            This is the standard IDependencyInjectionContainer implementation
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.#ctor(Grace.DependencyInjection.ExportEnvironment,Grace.DependencyInjection.ExportStrategyComparer,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Default Constructor
            </summary>
            <param name="environment">Environment that you want this container to operate in (RunTime, DesignTime, Or UnitTest</param>
            <param name="comparer">delegate that can be used to sort exports, if null is provided CompareExportStrategies will be used</param>
            <param name="disposalScopeProvider">allows you to provide a custom disposal scope provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.BlackListExport(System.String)">
            <summary>
            Black lists a particular export (Fullname)
            </summary>
            <param name="exportType">full name of the type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.BlackListExportType(System.Type)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType">type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the container.
            </summary>
            <param name="newLocator">new secondary locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddStrategyInspector(Grace.DependencyInjection.IStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="registrationDelegate">configuration delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="configurationModule"></param>
            <param name="scopeName"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add an object for disposal 
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove an object from the disposal scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="registrationDelegate"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="configurationModule"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="scopeName">the name of the scope that is being configured</param>
            <param name="registrationDelegate">configuration delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext">injection context for the locate</param>
            <param name="consider">filter to be used when locating</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>export T if found, other wise default(T)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType">type to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating export</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName">name of export to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="comparer"></param>
            <typeparam name="T">type to locate</typeparam>
            <returns>List of T, this will return an empty list if not exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name">export name to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="comparer"></param>
            <returns>List of objects, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <returns>list of object, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategyCollection(System.String)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportName"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Dispose">
            <summary>
            Dispose of the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate missing exports
            </summary>
            <param name="context">injection context</param>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="consider">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CompareExportStrategies(Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            This method compares 2 export strategies in a particular environment using ExportEnvironment attributes and ExportPriority attributes
            </summary>
            <param name="x">x compare object</param>
            <param name="y">y compare object</param>
            <param name="environment">environment to compare the strategies in</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Dispose(System.Boolean)">
            <summary>
            dispose implementation
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.AutoRegisterUnknown">
            <summary>
            If a concrete type is requested and it is not registered an export strategy will be created.
            Note: It will be scanned for attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.ThrowExceptions">
            <summary>
            If true exception will be thrown if a type can't be located, otherwise it will be caught and errors logged
            False by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.RootScope">
            <summary>
            The root scope for the container
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.SecondaryExportLocators">
            <summary>
            List of Export Locators
            </summary>
        </member>
        <member name="E:Grace.DependencyInjection.DependencyInjectionContainer.ResolveUnknownExports">
            <summary>
            By handling this event you can provide a value when no export was found
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportStrategyCollection">
            <summary>
            A collection of exports to be used for dependency resolution
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportEnvironment,Grace.DependencyInjection.ExportStrategyComparer)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionKernel"></param>
            <param name="environment"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Activate(System.String,System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the first export strategy that meets conditions
            </summary>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.ActivateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate all instances of a type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.AddExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy to the collection
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.RemoveExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Remove an export strategy from the collection
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Dispose">
            <summary>
            Dispose this collection of strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Dispose(System.Boolean)">
            <summary>
            Dispose this collection strategies
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Clone(Grace.DependencyInjection.Impl.InjectionKernel)">
            <summary>
            Clone the collection
            </summary>
            <param name="injectionKernel"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportStrategyCollection.ExportStrategies">
            <summary>
            A enumerable of export strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionKernel">
            <summary>
            InjectionKernel keeps a collection of exports to be used for resolving dependencies.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.#ctor(Grace.DependencyInjection.Impl.InjectionKernelManager,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IDisposalScopeProvider,System.String,Grace.DependencyInjection.ExportStrategyComparer)">
            <summary>
            Default constructor
            </summary>
            <param name="kernelManager">kernel manager for this kernel</param>
            <param name="parentScope"></param>
            <param name="scopeProvider">passing a null for scope provider is ok</param>
            <param name="scopeName"></param>
            <param name="comparer"></param>	
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName"></param>
            <param name="registrationDelegate"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the injection scope
            </summary>
            <param name="newLocator"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddStrategyInspector(Grace.DependencyInjection.IStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Clone(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IDisposalScopeProvider,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Clone the injection kernel, the rootscope cannot be cloned
            </summary>
            <param name="parentScope"></param>
            <param name="parentScopeProvider"></param>
            <param name="scopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            You can add extra configuration to the scope
            </summary>
            <param name="registrationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Configure the scope with a configuration module
            </summary>
            <param name="configurationModule"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context associated with this scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="comparer"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategyCollection(System.String)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportName"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate missing exports, this is an internal method
            </summary>
            <param name="context"></param>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Dispose(System.Boolean)">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.Container">
            <summary>
            The container this scope was created in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ScopeId">
            <summary>
            Unique identifier for the instance of the injection scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ScopeName">
            <summary>
            The scopes name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ParentScope">
            <summary>
            Parent scope, can be null if it's the root scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.SecondaryExportLocators">
            <summary>
            List of Export Locators
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionKernelManager">
            <summary>
            This class creates all injection kernels and contains all the configuration for all kernels
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.#ctor(Grace.DependencyInjection.DependencyInjectionContainer,Grace.DependencyInjection.ExportStrategyComparer,Grace.DependencyInjection.Impl.BlackList)">
            <summary>
            Default constructor
            </summary>
            <param name="container">container for the kernel manager</param>
            <param name="comparer">used to compare to export strategies for which one should be used</param>
            <param name="blackList">export strategy black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.SetRootScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            This method must be called before you configure any named kernels
            </summary>
            <param name="newRootScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            Allows you to configure a base kernel of a particular name
            </summary>
            <param name="kernelName">name of the kernel being configured</param>
            <param name="registrationDelegate">registration delegate to call configure with</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.CreateNewKernel(Grace.DependencyInjection.Impl.InjectionKernel,System.String,Grace.DependencyInjection.ExportRegistrationDelegate,Grace.DependencyInjection.IDisposalScopeProvider,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Create a new Kernel of a particular name
            </summary>
            <param name="parentKernel">the parent kernel</param>
            <param name="kernelName">name of the kernel to create</param>
            <param name="registrationDelegate"></param>
            <param name="parentScopeProvider"></param>
            <param name="scopeProvider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernelManager.BlackList">
            <summary>
            Black list associated with this kernel manager
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernelManager.Container">
            <summary>
            Container this kernel manager is associated with
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionContext">
            <summary>
            Default implementation of IInjectionContext
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Constructor that uses requesting scope as disposal scope
            </summary>
            <param name="requestingScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.#ctor(Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="disposalScope"></param>
            <param name="requestingScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.GetEnumerator">
            <summary>
            Returns an enumeration of exports
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumation of exports
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Locate``1">
            <summary>
            Locate an export by type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Locate(System.String)">
            <summary>
            Locate an export by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Export``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export by type for this injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Export(System.Type,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Export by type
            </summary>
            <param name="exportType"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Export(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Register an export by name for this injection context
            </summary>
            <param name="name"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.IncrementResolveDepth">
            <summary>
            Increment the resolve depth by one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.DecrementResolveDepth">
            <summary>
            Decrement the resolve depth by one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add(System.Object)">
            <summary>
            Add a new object to injection context for export
            </summary>
            <param name="export"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Add a new Type to injection context for export
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.DisposalScope">
            <summary>
            Disposal scope for the injection context
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.RequestingScope">
            <summary>
            The scope that the request originated in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.TargetInfo">
            <summary>
            The target information for the current injection
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.MaxResolveDepth">
            <summary>
            Max resolve depth allowed
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.IPerRequestLifestyleProvider">
            <summary>
            This interface is used by the SingletonPerRequestContainer
            It is used to provide a per request Lifestyle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.IPerRequestLifestyleProvider.ProvideContainer">
            <summary>
            Called to provide a new per request Lifestyle container
            </summary>
            <returns>new Lifestyle container</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonLifestyle">
            <summary>
            The SingletonContainer is a Lifestyle container that when used on an export makes it into a singleton
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Dispose">
            <summary>
            Dispose of the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle">
            <summary>
            Exports that use this will be shared per injection context and are considered transient
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Transient">
            <summary>
            Always true
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle">
            <summary>
            Exports that use this will be shared per request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Dispose">
            <summary>
            Dispose the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.LocateContainer(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locates an ILifestyle
            </summary>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Transient">
            <summary>
            Singleton Per Request are considered transient when resolving
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle">
            <summary>
            This Lifestyle container will create an instance per scope instance.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Dispose">
            <summary>
            Dispose this Lifestyle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle">
            <summary>
            Thread static container will share an export per thread
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Dispose">
            <summary>
            Dispose the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle">
            <summary>
            The WeakSingletonContainer class will create an instance of the object and keep a weak reference to it
            A new instance will be requested upon request if the previous instance has been GC'd
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Dispose">
            <summary>
            Dispose of container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Meta`1">
            <summary>
            Meta class is a wrapper around an export 
            </summary>
            <typeparam name="T">Type to request</typeparam>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`1.Value">
            <summary>
            Resolved Value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`1.Metadata">
            <summary>
            Metadata for the resolved value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Owned`1">
            <summary>
            THis class can be used to scope 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Owned`1.SetValue(`0)">
            <summary>
            Sets the export value. It will only work once.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Owned`1.Value">
            <summary>
            The export value that is owned
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.DependencyResolveException">
            <summary>
            Exception thrown when you can't resolve a dependency
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.DependencyResolveException.#ctor(System.Type,System.String,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="injectedType"></param>
            <param name="injectedName"></param>
            <param name="importName"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DependencyResolveException.InjectedType">
            <summary>
            Type being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DependencyResolveException.InjectedName">
            <summary>
            Name of property or parameter being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DependencyResolveException.ImportName">
            <summary>
            Export name or Type that is being located
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ResolveUnknownExportArgs">
            <summary>
            This event arg can be handled to resolve unknown types.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ResolveUnknownExportArgs.#ctor(Grace.DependencyInjection.IInjectionContext,System.String,System.Type)">
            <summary>
            CSTOR
            </summary>
            <param name="injectionContext"></param>
            <param name="requestedName"></param>
            <param name="requestedType"></param>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.InjectionContext">
            <summary>
            Injection context for the resolve request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.RequestedName">
            <summary>
            The name of the export that was requested. Typically the full type name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.RequestedType">
            <summary>
            The type that was requested, can be null if requested by name only
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.ExportedValue">
            <summary>
            You can provide an export value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.SortBy">
            <summary>
            Static class that provides IComparer(T) classes for sorting
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.TypeFilterGroup">
            <summary>
            Groups together a set of type filters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypeFilterGroup.#ctor(System.Func{System.Type,System.Boolean}[])">
            <summary>
            Default Constructor
            </summary>
            <param name="typeFilters"></param>
        </member>
        <member name="M:Grace.DependencyInjection.TypeFilterGroup.op_Implicit(Grace.DependencyInjection.TypeFilterGroup)~System.Func{System.Type,System.Boolean}">
            <summary>
            Automatically convert from TypefilterGroup to Func(Type,bool)
            </summary>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.TypesThat">
            <summary>
            That class provides Type filter methods to be used in ExportInterfaces and SelectTypes method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.op_Implicit(Grace.DependencyInjection.TypesThatConfiguration)~System.Func{System.Type,System.Boolean}">
            <summary>
            Automatically convert from TypefilterGroup to Func(Type,bool)
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Diagnostics.IInjectionScopeDiagnostic">
            <summary>
            Provides diagnostic information about an IInjectionScope
            Used by visual studio for debugging
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.IInjectionScopeDiagnostic.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor takes scope as only parameter
            </summary>
            <param name="injectionScope">injection scope to diagnose</param>
        </member>
        <member name="M:Grace.Diagnostics.IInjectionScopeDiagnostic.CalculatePossibleMissingDependencies(Grace.DependencyInjection.IExportLocator)">
            <summary>
            Calculates a list of possible missing dependencies
            </summary>
            <param name="locator"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Diagnostics.IInjectionScopeDiagnostic.Environment">
            <summary>
            Environment for the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.IInjectionScopeDiagnostic.ParentScope">
            <summary>
            Parent scope for injection scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.IInjectionScopeDiagnostic.ScopeName">
            <summary>
            Name of scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.IInjectionScopeDiagnostic.ScopeId">
            <summary>
            Unique Id for the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.IInjectionScopeDiagnostic.Exports">
            <summary>
            list of all exports
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.IInjectionScopeDiagnostic.PossibleMissingDependencies">
            <summary>
            List of possible missing dependencies
            Note: This is just a possible missing dependency
            Using static analysis this is a best attempt at resolving.
            Because of conditions and other factors it's possible to have no missing dependencies listed
            and still fail to resolve.
            </summary>
        </member>
        <member name="T:Grace.LanguageExtensions.IEnumerableExtensions">
            <summary>
            Extensions for IEnumerable
            </summary>
        </member>
        <member name="M:Grace.LanguageExtensions.IEnumerableExtensions.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Apply an action to an IEnumerable
            </summary>
            <typeparam name="T">t type</typeparam>
            <param name="enumerable">enumerable</param>
            <param name="action">action to apply</param>
        </member>
        <member name="T:Grace.Logging.DebugConsoleLog">
            <summary>
            Logs all message to debug console
            </summary>
        </member>
        <member name="T:Grace.Logging.ILog">
            <summary>
            an instance of a log
            </summary>
        </member>
        <member name="M:Grace.Logging.ILog.Debug(System.Object,System.Exception)">
            <summary>
            Log a Debug message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.DebugFormat(System.String,System.Object[])">
            <summary>
            Log a Debug formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Info(System.Object,System.Exception)">
            <summary>
            Log a Info message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.InfoFormat(System.String,System.Object[])">
            <summary>
            Log a Info formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Warn(System.Object,System.Exception)">
            <summary>
            Log a Warn message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.WarnFormat(System.String,System.Object[])">
            <summary>
            Log a Warn formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Error(System.Object,System.Exception)">
            <summary>
            Log an Error message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Log an Error format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Fatal(System.Object,System.Exception)">
            <summary>
            Log an Fatal message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.FatalFormat(System.String,System.Object[])">
            <summary>
            Log an Fatal format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.ILog.IsDebugEnabled">
            <summary>
            Is Debug Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsInfoEnabled">
            <summary>
            Is Info Log Level  Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsWarnEnabled">
            <summary>
            Is Warn Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsErrorEnabled">
            <summary>
            Is Error Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsFatalEnabled">
            <summary>
            Is Fatal Log Level Enabled
            </summary>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.#ctor(System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="logName"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Debug(System.Object,System.Exception)">
            <summary>
            Log a Debug message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.DebugFormat(System.String,System.Object[])">
            <summary>
            Log a Debug formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Info(System.Object,System.Exception)">
            <summary>
            Log a Info message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.InfoFormat(System.String,System.Object[])">
            <summary>
            Log a Info formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Warn(System.Object,System.Exception)">
            <summary>
            Log a Warn message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.WarnFormat(System.String,System.Object[])">
            <summary>
            Log a Warn formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Error(System.Object,System.Exception)">
            <summary>
            Log an Error message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Log an Error format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Fatal(System.Object,System.Exception)">
            <summary>
            Log an Fatal message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.FatalFormat(System.String,System.Object[])">
            <summary>
            Log an Fatal format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsDebugEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsInfoEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsWarnEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsErrorEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsFatalEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="T:Grace.Logging.DebugConsoleLogService">
            <summary>
            Log service that writes everything to the debug console
            </summary>
        </member>
        <member name="T:Grace.Logging.ILogService">
            <summary>
            Log service to be used by Logger
            </summary>
        </member>
        <member name="M:Grace.Logging.ILogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.ILogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.DevNullLog">
            <summary>
            Logger that does nothing
            </summary>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Debug(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.DebugFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Info(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.InfoFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Warn(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.WarnFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Error(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Fatal(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.FatalFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsDebugEnabled">
            <summary>
            Is Debug Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsInfoEnabled">
            <summary>
            Is Info Log Level  Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsWarnEnabled">
            <summary>
            Is Warn Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsErrorEnabled">
            <summary>
            Is Error Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsFatalEnabled">
            <summary>
            Is Fatal Log Level Enabled, always false
            </summary>
        </member>
        <member name="T:Grace.Logging.DevNullLogService">
            <summary>
            Returns loggers that do nothing
            </summary>
        </member>
        <member name="M:Grace.Logging.DevNullLogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DevNullLogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.Logger">
            <summary>
            Static logging class for the framework. 
            </summary>
        </member>
        <member name="M:Grace.Logging.Logger.SetLogService(Grace.Logging.ILogService)">
            <summary>
            Set the logger to be used for the containers
            </summary>
            <param name="logService"></param>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger(System.Type)">
            <summary>
            Get an ILog instance
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger``1">
            <summary>
            Get an ILog instance
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger(System.String)">
            <summary>
            Get an ILog by name
            </summary>
            <param name="logName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.Debug(System.String,System.String,System.Exception)">
            <summary>
            Log a debug message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.Logger.Error(System.String,System.String,System.Exception)">
            <summary>
            Log an error message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="P:Grace.Logging.Logger.LogService">
            <summary>
            Get the log service for the framework
            </summary>
        </member>
        <member name="T:Grace.Logging.LogLevel">
            <summary>
            Log Level enumeration
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Debug">
            <summary>
            Debug level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Info">
            <summary>
            Info Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Warn">
            <summary>
            Warn Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Error">
            <summary>
            Error Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Fatal">
            <summary>
            Fatal Level
            </summary>
        </member>
        <member name="T:Grace.Utilities.SafeDictionary`2">
            <summary>
            Safe dictionary class, lifted shamelessly from TinyIoC
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Try and get a key value pair from the dictionary
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.Remove(`0)">
            <summary>
            Remove an entry from the dictionary
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.Clear">
            <summary>
            Clear the dictionary
            </summary>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.Dispose">
            <summary>
            Dispose of the dictionary
            </summary>
        </member>
        <member name="P:Grace.Utilities.SafeDictionary`2.Item(`0)">
            <summary>
            Set a value into the dictionary
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.SafeDictionary`2.Keys">
            <summary>
            Keys in the dictionary
            </summary>
        </member>
        <member name="T:Grace.Utilities.TaskHelper">
            <summary>
            Utility methods to help with creating tasks
            </summary>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.CreateEmptyTask">
            <summary>
            Creates a new empty task
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.NullTask``1">
            <summary>
            Creates a null task
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.ReturnTask``1(``0)">
            <summary>
            Returns a value as a task
            </summary>
            <typeparam name="T"></typeparam>
            <param name="returnValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Utilities.WeakAction">
            <summary>
            Represents a delegate that will not hold a reference to it's target
            </summary>
        </member>
        <member name="M:Grace.Utilities.WeakAction.#ctor(System.Action)">
            <summary>
            Default Action
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Grace.Utilities.WeakAction.Invoke">
            <summary>
            Invoke the action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction.IsAlive">
            <summary>
            True if Target is alive
            </summary>
        </member>
        <member name="T:Grace.Utilities.WeakFunc`1">
            <summary>
            Represents a Func(T) that will not hold a reference to the target
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`1.#ctor(System.Func{`0})">
            <summary>
            Default Constructor
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`1.Invoke">
            <summary>
            Invoke the Func
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`1.IsAlive">
            <summary>
            Is the target alive
            </summary>
        </member>
    </members>
</doc>
